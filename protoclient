#!/usr/bin/perl



#This file is part of Muteswan.

#Muteswan is free software: you can redistribute it and/or modify
#it under the terms of the GNU Affero General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#Muteswan is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU Affero General Public License for more details.

#You should have received a copy of the GNU Affero General Public License
#along with Muteswan.  If not, see <http://www.gnu.org/licenses/>.

use YAML;
use Crypt::CBC;
#use Crypt::Blowfish;
use Crypt::DES_EDE3;
use Crypt::Rijndael;
use Getopt::Std;
use Data::UUID;
use Digest::SHA qw(sha1_hex);
use LWP::UserAgent;
use LWP::Protocol::socks;
use GD::Barcode::QRcode;
use MIME::Base64;
use JSON;



# this is a prototype client for aftff

# options:
# home server: -h - set home server
# datadevice: -d - data device
# exportdevice: -e - export device

# function: command line example - description
# init new store on data device: init - gens master pw and store
# create profile/key: create keyname - create a new key
# server info: servinfo - view manifest on server
# show keys: show|ls - list keys (friends)
# edit key: editkey keyid - edit a key and add metadata
# export key(s): export key1 key2 keyn ... - export list of keys to
# import key(s): import key1 key2

# global
our $agent = 'aftff 0.1';

our %commands = (
	'create' => { 'sub' => 'create_sub' },
	'init' => { 'sub' => 'init_sub' },
	'servinfo' => { 'sub' => 'servinfo_sub' },
	'show' => { 'sub' => 'showkeys_sub' },
	'lskeys' => { 'sub' => 'showkeys_sub' },
	'lsmsgs' => { 'sub' => 'showmsgs_sub' },
	'msg' => { 'sub' => 'msg_sub' },
	'rmsg' => { 'sub' => 'rmsg_sub' },
	'edit' => { 'sub' => 'editkey_sub' },
	'export' => { 'sub' => 'export_sub' },
	'import' => { 'sub' => 'import_sub' },
	'exporttxt' => { 'sub' => 'exporttxt_sub' },
	'longpoll' => { 'sub' => 'longpoll_sub' },
);


### Main
my %opts;
getopt('h:d:e:', \%opts);
my $command = shift(@ARGV);
our $device = $opts{'d'};
our $server = $opts{'h'};
our $master_password = undef;

my $iv = q(0123456701234567);

if (!$command) {
	usage();
}

print STDERR "# Using device: $device\n";
our $aftff_keys = &load_aftff_keys();


my $cmdsub = $commands{$command}{sub};
if (!$cmdsub) {
	print "Unknown command: $command\n";
	usage();
}
&$cmdsub(\%opts);


###
### Subs
###
sub load_aftff_keys {
	#my $device = shift;
	my $data;
	return($data) if $command eq 'init';

	$master_password = passwordprompt();

	my $enc = read_raw_data();
	my $plaintext = decrypt($master_password,$enc);

	$data = Load($plaintext);
	
	return($data);
}

sub save_aftff_keys {
	my $key = shift;
	my $dumpdata = Dump($aftff_keys);
	print "SAVING: $dumpdata\n";
	my $enc = encrypt($key,$dumpdata);
	write_raw_data($enc);
}

sub read_raw_data {
	#my $device = shift;
	open(DEVICE,"$device") || die "Cannot open $device\n";
	my $data;

	my $prev1 = undef;
	my $prev2 = undef;

	while(1) {

		my $buf;
		my $len = sysread(DEVICE,$buf,1);


		if ($buf eq 'D' && $prev1 eq 'N' && $prev2 eq 'E') {
			chop($data);
			chop($data);
			last;			
		}


		$data .= $buf;
		$prev2 = $prev1;
		$prev1 = $buf;
	}
	close(DEVICE);
	return($data);
}

sub write_raw_data {
	my $data = shift;
	$data .= "END";
	print "Device: $device\n";
	open(DEVICE,">$device");
	print DEVICE $data;
	close(DEVICE);
}

sub decrypt {
	my $key = shift;
	my $data = shift;

	my $cipher = Crypt::CBC->new( '-key' => $key,
				      '-literal_key'	=> 1,
				       '-header' => 'none',
			              '-padding' => 'standard',
				       '-iv' => $iv,
				     '-keysize' => '16',
				     '-blocksize' => '16',
				     '-cipher' => 'Rijndael' );
	my $plaintext = $cipher->decrypt($data);

	return($plaintext);
}

sub encrypt {
	my $key = shift;
	my $plaintext = shift;
	my $cipher = Crypt::CBC->new( '-key' => $key,
				       '-literal_key' => 1,
				       '-header' => 'none',
				       '-iv' => $iv,
			               '-padding' => 'standard',
				     '-keysize' => '16',
				     '-blocksize' => '16',
				     '-cipher' => 'Rijndael' );
	my $data = $cipher->encrypt($plaintext);
	return($data);
}


sub usage {
	print "aftffclient\n";
	print "protoclient -d storefile cmd [args]\n";
	print "\n";
	print "storefile is file of arbitrary size that will be used to store the\n";
	print "crypto information. If empty, it will be initialized.\n";
	print "cmd is one of the following cmds with arguments:\n\n";
	print "create - create a new ring\n";
	print "lskeys - list keys in store\n";
	print "lsmsgs name - list msg index for ring name\n";
	print "rmsg name id - read message id from ring name\n";
	print "msg name - write a new message for ring name\n";
	print "export name - export a png qrcode for ring name\n";
	exit;
}


sub init_sub {
	my $opts = shift;

	if (!device) {
		error("We need a device");
	}

	my $password = passwordprompt();

	print "Password: $password\n";
	save_aftff_keys($password);
}

sub create_sub {
	# FIXME: not a good way to get keys at all
	my $key = `cat /dev/urandom | head -n 200 | sha256sum - | cut -d ' ' -f 1`;
	chomp($key);
	my $key = substr($key,0,16);
	print $key;
	my $digest = sha1_hex($key);
	print "\nNew key: $key\n";
	print "\nNew digest: $digest\n";
	$$aftff_keys{$digest}{key} = $key;


	my $name = get_string_from_user("Please provide a descriptive name for this key:\n");
	$$aftff_keys{$digest}{name} = $name;

	my $shortname = get_string_from_user("Please provide a short name for this key: ");
	my $host = get_string_from_user("Enter onion hidden host: ");
	$$aftff_keys{$digest}{name} = $name;
	$$aftff_keys{$digest}{shortname} = $shortname;
	$$aftff_keys{$digest}{at} = $host;

	save_aftff_keys($master_password);
	&export_txt($name,$key,$host);
}


sub showmsgs_sub {
	my $keyhash = shift(@ARGV);

	my $hash = find_short_name($keyhash);
	if ($hash) {
		$keyhash = $hash;
	}

	if (!$$aftff_keys{$keyhash}) {
		error("No aftff keyhash supplied or not found.\n");
	}

	if (!$server && !$$aftff_keys{$keyhash}{at}) {
		print "Error, no server host (-h optiont) defined.\n";
		exit;
	} elsif ($$aftff_keys{$keyhash}{at}) {
		$server = $$aftff_keys{$keyhash}{at};
	}

	my $ua = new LWP::UserAgent( agent => $agent );
	$ua->proxy('http' => 'socks://127.0.0.1:9050');
	my $req = new HTTP::Request("GET" => "http://$server/$keyhash");
	my $res = $ua->request($req);
	#print "# Response: " . $res->code . "\n";
	if ($res->code != 200) {
	  print "Error, unable to get data.\n";
	} else {
	  #print "# Message index:\n";
	  #print "\n" . $res->content() . "\n";
	  print $res->header( 'Last-Message' ) . "\n";
	}
}

sub showkeys_sub {
	print Dump($aftff_keys);
}

sub msg_sub {

	my $keyhash = shift(@ARGV);

	my $hash = find_short_name($keyhash);
	if ($hash) {
		$keyhash = $hash;
	}

	if (!$$aftff_keys{$keyhash}) {
		error("No aftff keyhash supplied or not found.\n");
	}

	if (!$server && !$$aftff_keys{$keyhash}{at}) {
		print "Error, no server host (-h optiont) defined.\n";
		exit;
	} elsif ($$aftff_keys{$keyhash}{at}) {
		$server = $$aftff_keys{$keyhash}{at};
	}


	print "# Enter your message, end with . on single line:\n";

	my $message = get_data_from_user();

	my $enc_message = encrypt($$aftff_keys{$keyhash}{key},$message);
	submit_message($keyhash,$enc_message);

	print "# Message posted.\n";

}

sub rmsg_sub {

	my $keyhash = shift(@ARGV);
	my $msgid = shift(@ARGV);

	my $hash = find_short_name($keyhash);
	if ($hash) {
		$keyhash = $hash;
	}

	if (!$$aftff_keys{$keyhash}) {
		error("No aftff keyhash supplied or not found.\n");
	}

	if (!defined($msgid)) {
		error("No message id supplied.\n");
	}

	if (!$server && !$$aftff_keys{$keyhash}{at}) {
		print "Error, no server host (-h optiont) defined.\n";
		exit;
	} elsif ($$aftff_keys{$keyhash}{at}) {
		$server = $$aftff_keys{$keyhash}{at};
	}



	print "# Fetching message $msgid\n";

	my $ua = new LWP::UserAgent( agent => $agent );
	$ua->proxy('http' => 'socks://127.0.0.1:9050');
	my $req = new HTTP::Request("GET" => "http://$server/$keyhash/$msgid");
	my $res = $ua->request($req);
	print "# Response: " . $res->code . "\n";
	if ($res->code != 200) {
		print "Error, unable to get data.\n";
	} else {
	  open(DB,">/tmp/debug.txt");
	  print DB $res->content();
	  close(DB);
	  
	  my $json = JSON->new->allow_nonref;
	  my $jsonObj = $json->decode($res->content());
	  my $plaintext = decrypt($$aftff_keys{$keyhash}{key},decode_base64($$jsonObj{'message'}));
	  print Dump($plaintext);
	}

}

sub editkey_sub {
	my $keyhash = shift(@ARGV);

	my $hash = find_short_name($keyhash);
	if ($hash) {
		$keyhash = $hash;
	}

	if (!$$aftff_keys{$keyhash}) {
		error("No aftff keyhash supplied or not found.\n");
	}

	open(TMP,">/tmp/aftff_edit.$$") || die "Could not open /tmp/aftff_edit.$$\n";
	my $keydata = $$aftff_keys{$keyhash};
	print TMP Dump($keydata);
	close(TMP);
	system("vi /tmp/aftff_edit.$$");
	my $newdata;
	open(TMP,"/tmp/aftff_edit.$$") || die "Could not reopen /tmp/aftff_edit.$$\n";
	while(<TMP>) {
		$newdata .= $_;	
	}
	close(TMP);
	$$aftff_keys{$keyhash} = Load($newdata);
	save_aftff_keys($master_password);
	print "Key updated.\n";
	unlink("/tmp/aftff_edit.$$");
}


sub export_sub {
	my $keyhash = shift(@ARGV);

	my $hash = find_short_name($keyhash);
	if ($hash) {
		$keyhash = $hash;
	}

	if (!$$aftff_keys{$keyhash}) {
		error("No aftff keyhash supplied or not found: $keyhash\n");
	}

print STDERR "$$aftff_keys{$keyhash}{name}+$$aftff_keys{$keyhash}{key}\@$$aftff_keys{$keyhash}{at}\n";
	export_png($$aftff_keys{$keyhash}{name},$$aftff_keys{$keyhash}{key},$$aftff_keys{$keyhash}{at});


}

sub longpoll_sub {


	my $keyhash = shift(@ARGV);
	my $msgid = shift(@ARGV);

	my $hash = find_short_name($keyhash);
	if ($hash) {
		$keyhash = $hash;
	}

	if (!$$aftff_keys{$keyhash}) {
		error("No aftff keyhash supplied or not found.\n");
	}

	if (!defined($msgid)) {
		error("No message id supplied.\n");
	}

	if (!$server && !$$aftff_keys{$keyhash}{at}) {
		print "Error, no server host (-h optiont) defined.\n";
		exit;
	} elsif ($$aftff_keys{$keyhash}{at}) {
		$server = $$aftff_keys{$keyhash}{at};
	}


	print "# Long polling...\n";

	my $ua = new LWP::UserAgent( agent => $agent );
	$ua->proxy('http' => 'socks://127.0.0.1:9050');
	my $req = new HTTP::Request("GET" => "http://$server/$keyhash/longpoll/$msgid");
	my $res = $ua->request($req);
	print "# Response: " . $res->code . "\n";
	if ($res->code != 200) {
		print "Error, unable to get data.\n";
	} else {
	  open(DB,">/tmp/debug.txt");
	  print DB $res->content();
	  close(DB);
	  
	  my $json = JSON->new->allow_nonref;
	  my $jsonObj = $json->decode($res->content());
	  my $plaintext = decrypt($$aftff_keys{$keyhash}{key},decode_base64($$jsonObj{'message'}));
	  print Dump($plaintext);
	}

	
}

sub exporttxt_sub {
	my $keyhash = shift(@ARGV);

	my $hash = find_short_name($keyhash);
	if ($hash) {
		$keyhash = $hash;
	}

	if (!$$aftff_keys{$keyhash}) {
		error("No aftff keyhash supplied or not found: $keyhash\n");
	}

	export_txt($$aftff_keys{$keyhash}{name},$$aftff_keys{$keyhash}{key},$$aftff_keys{$keyhash}{at});
}

sub export_raw_sub {
	my $keyhash = shift(@ARGV);
	my $directory = shift(@ARGV);

	my $hash = find_short_name($keyhash);
	if ($hash) {
		$keyhash = $hash;
	}

	if (!$$aftff_keys{$keyhash}) {
		error("No aftff keyhash supplied or not found.\n");
	}

	if (!$directory) {
		error("Directory '$directory' not found\n");
	}

	my $keydata = Dump($$aftff_keys{$keyhash});
	open(EXPORTFILE,">$directory/$keyhash") || die "Could not open $directory/$keyhash\n";
	print EXPORTFILE $keydata;
	close(EXPORTFILE);
	print "Key $keyhash exported to $directory.\n";
}

# FIXME: only allow import from png files using zxing qrcode reader
sub import_sub {
	my $importfile = shift(@ARGV);
	if (! -f $importfile) {
		error("File $importfile not found\n");
	}

	my @parts = split('/', $importfile);
	my $keyhash = pop(@parts);

	if ($$aftff_keys{$keyhash}) {
		error("Key $keyhash already exists!\n");
	}
	
	my $importdata;
	open(IMPORTFILE,"$importfile") || die "Could not open $importfile\n";
	while(<IMPORTFILE>) {
		$importdata .= $_;
	}
	close(IMPORTFILE);

	my $keydata = Load($importdata);
	$$aftff_keys{$keyhash} = $keydata;
	save_aftff_keys($master_password);
	print "Key $keyhash imported.\n";
}



### utility
sub submit_message {
	my $key = shift;
	my $message = shift;


	my $json = JSON->new->allow_nonref;
	my $json_txt = $json->encode( { 'message' => encode_base64($message)} );


	my $ua = new LWP::UserAgent( agent => 'aftff 0.1' );
	$ua->proxy('http' => 'socks://127.0.0.1:9050');
	my $req = new HTTP::Request("POST" => "http://$server/$key",undef,$json_txt);
	my $res = $ua->request($req);
	print $res->code . ": " . $res->content . "\n";
}


sub error  {
	my $string = shift;
	print "$string\n";
	exit(1);
}

sub passwordprompt {
	my $password;
	print STDERR "# Please provide a master password: ";
	while(<STDIN>) {
		chomp;
		$password = $_;
		last;
	}

	my $lendif = length($password) - 16;
	if ($lendif == 0) {
		return($password);
	} elsif ($lendif < 0) {
		for (my $i=$lendif; $i<0; $i++) {
			$password .=  "X";
		}
		return($password);
	} elsif ($lendif > 0) {
		for (my $i=$lendif; $i>0; $i--) {
			chop($password);
		}
		return($password);
	}

}

sub get_string_from_user {
	my $prompt = shift;
	my $data;
	print STDERR "# $prompt";
	while(<STDIN>) {
		chomp;
		$data = $_;
		last;
	}
	return($data);
}

sub get_data_from_user {
	my $data;
	while(<STDIN>) {
		my $line = $_;
		if ($line =~ /^\.$/) {
			print "# Sending message...\n";
			last;
		}
		$data .= $line;
	}
	return($data);
}

sub find_short_name {
	my $shortname = shift;
	foreach my $k (keys %{$aftff_keys}) {
		if ($$aftff_keys{$k}{shortname} eq $shortname) {
			return $k;
		}
	}
}

sub export_txt {

	my $name = shift;
	my $key = shift;
	my $at = shift;


	print "$name+$key\@$at\n";

}

sub export_png {
	my $name = shift;
	my $key = shift;
	my $at = shift;

	my $barcode = new GD::Barcode::QRcode("$name+$key\@$at",{'ModuleSize' => 5, 'Version' => 7});
	print $barcode->plot->png;
}
